---
title: A method for describing changes to emails
abbrev: Email Modification Versioning
docname: draft-gondwana-dkim2-message-instance-00
submissionType: IETF
category: std
updates:
obsoletes:
ipr: trust200902
keyword: Internet-Draft
stand_alone: yes
pi: [toc, sortrefs, symrefs]

author:
 -
    ins: B. Gondwana
    name: Bron Gondwana
    org: Fastmail Pty Ltd
    street: Level 2, 114 William Street
    code: 3000
    country: Australia
    phone: "+61 457 416 436"
    email: brong@fastmailteam.com

normative:
    DKIM: RFC6376
    IMAP: RFC9051

--- abstract

This memo describes a method for describing the changes made to an email
during common email modifications, for example those caused by mailing lists
and forwarders.

While this is general enough to be used for any changes, it is anticipated that
this method will normally be used for removing added data rather than large
complex changes.

This method also captures hashes of important features of the message,
allowing validation that the changes were described correctly, and allowing
a signature which covers the Message-Instance header to, by extention, ensure
that the important content of the message is unchanged.

--- middle

# Background and motivations

Currently, when an email is sent with a DKIM signature, the message can go
through multiple forwarders and still be authenticated, however if a single
change is made to a header which is covered by the signature, or to the body,
then the signature no longer validates - and it's impossible for the receiver
to know what was changed, or even if the entire message was replaced.

By producing a way to describe changes, the recipient can examine the sections
which were changed and determine whether the change was malicious.  By undoing
the changes, it is possible to recreate a message which matches the original
signature, and hence provide accountability for the content which was present
in the copy of the message to which the signature was applied.

# The Message-Instance Header Field

This document describes an ordered set of header fields, each of
which describes the message at a specific version, along with
instructions on how to convert that version back to the previous
version.

To well formed, a message must have a monotonically increasing
set of Message-Instance header fields, with the first having mi=1
and each having an increasing integer number, with no gaps.

## Message-Instance Header

The format of the value is a tag-list.  Tag-lists contain key=value; key2=value2; - they can be wrapped,
and all whitespace is normalised to a single space.

TODO: we need to specify tag-list.

Tag        | Type        | Value
---------- | -----       | ------
mi         | position    | Instance number (range: 1 to 100)
h          | headerlist  | List of headers signed by the hh field (separated by :)
a          | hash-alg    | Hash Algorithm used (at least sha256 must be supported); used for hh, bh and ph
hh         | base64      | Header Hash for the named headers, using the 'relaxed' header algorith from {{DKIM}}
bh         | base64      | Body Hash, using the 'relaxed' body algorithm from {{DKIM}}
ph.n.m     | base64      | Hash for the binary representation of the numbered mime part, after removal of any content-transfer-encoding (this is the data returned by `FETCH BINARY[n.m]` as described in {{IMAP}} section 7.5.2)
b          | body-recipe | Recipe to replicate the previous version of the message body
h.header   | head-recipe | Recipe to replicate the previous version of the named header field

TODO: do we want to add 'bh.n.m' to hash the un-decoded body of individual MIME parts,
and hh.n.m to hash the headers of the MIME part as well?

## body-recipe

The Body Recipe is a comma separated list of instructions.  Each instruction starts with a
prefix.  Commas can be followed by optional whitespace.

The presence of a recipe replaces the previous value, so the tag-value `b=` creates an empty body, while the tag-value `b=b:` creates a message with a single blank line for the body.

Prefix   | Value     | Action
------   | -----     | ------
c:       | start-end | Copy the lines (inclusive) numbered from 1.  E.g. "c:1-3" copies the first three lines.
b:       | base64    | Decode the base64 to get the value of a line to insert.  The base64 value does NOT include the trailing CRLF, which must be added at the end of the line, hence "b:" means insert an empty line, and "b:SGVsbG8=" inserts the line "Hello".
z        | none      | If present, says that changes have been made to the body which can not be described to get back to the earlier version, meaning the signing system takes accountability for the full content.

## header-recipe

The Header Recipe is a comma separated list of instructions.  Each instruction starts with a
prefix.  Commas can be followed by optional whitespace.

While key names are case insensitive, implementations SHOULD create the header with the same
case as the key.

The presence of a recipe removes every instance of the named header field before applying the recipe,
so the tag-value `h.foo=` removes all instances of Foo from the message.

Prefix   | Value       | Action
------   | -----       | ------
c:       | start-end   | Copy the values of the header-fields with the indexes, numbered from 1 and starting at the bottom;
b:       | base64      | Decode the base64 to get the value of a header field to insert. The base64 value does NOT include the trailing CRLF, which must be added at the end of the line, hence "b:" means insert a header-field with an empty value.
z        | none        | If present, says that changes have been made to the named header field which can not be described to get back to the earlier version, meaning the signing system takes accountability for the full content of this message.

NOTE: the headers are inserted from the bottom, i.e. prepended to the message in the order that they are named.

e.g. given a message with headers:

~~~
Foo: three
Foo: two
Foo: one
~~~

And the recipe: `h.Foo=c:1-1,b:Zm91cg==,c:2-3`

The output will be:
~~~
Foo: three
Foo: two
Foo: four
Foo: one
~~~

## Examples

Example for a message which has had Subject and From replaced,
and Reply-To added.

~~~~
From: brong@fastmailteam.com.dmarc.fail
To: dkim2@lists.ietf.org
Reply-To: dkim2@lists.ietf.org
Message-Instance: mi=2;
 h.Subject=b:QSByZXBsYWNlbWVudCBmb3IgREtJTQ==;
 h.From=b:YnJvbmdAZmFzdG1haWx0ZWFtLmNvbQo=;
 h.Reply-To=
~~~~

Example:

~~~~
Message-Instance: mi=3; b=c:1-500,c:520-520
~~~~

Example - a URL was substituted in the content of the body (complex, but still
easily doable!)

~~~~
Message-Instance: mi=4;
 b=c:1-500,
   b:PGEgaHJlZj0iaHR0cHM6Ly93d3cuZXhhbXBsZS5jb20iPkV4YW1wbGU8L2E+Cg==,
   c:501-702
~~~~

It is expected that 'c' will normally be used to copy lines directly from
the new message, however in cases where a message needs to transit 7-bit systems
cleanly, the email modifier may need to re-encode the octets of the original message,
and this allows for doing so, albeit at some expense in header bloat!

# Calculating the hh value

The algorithm for calculating the hh value is to iterate through the header names in the
`h=` field and add each header field which matches that name with a case insignificant
comparison, starting from the bottom (all header-fields start from the bottom and count
upwards).  This uses the 'relaxed' algorithm described in {{DKIM}} section 2.4.3 for
headers, lowercasing field names, and normalising whitespace in header bodies, with
a trailing CRLF.  These values are added to the digest.

The final 'hh=' value includes all the listed headers in the h= field, and nothing
else.  There are no implicit fields included.  ALL copies of every named header field
is included.  If a later Message-Instance is created where the header fields named in
an earlier Message-Instance are changed, it MUST describe how to get back to the
previous values, or affirmatively declare (with 'z') that it isn't doing so.

These headers are fed in order to the algorithm specified by the a= tag value,
encoding the result as base64.

# Calculating the bh value

The algorithm for calculating the bh value is to process all the lines of the body
with the relaxed algorithm declared in {{DKIM}} section 3.4.4, feeding them in
order to the algorithm specified by the a= tag value, and encoding the result as base64.

# Calculating the ph.x.y values

For each MIME part following the algorithm used in {{IMAP}} section 6.4.5.1, decode
the content as a binary data stream after performing decoding as described by
the section's `Content-Transfer-Encoding`, and feed it to the algorithm specified
by the a= tag value, encoding the result as base64.

# Iterative application

To get back to the original message and confirm that it was unchanged, it is necessary
to apply this algorith iteratively.

For example if you receive a message for which there is a modification to the
headers at `mi=3` and a modification to both headers and body at `mi=2`, to recreate the
original message you would first apply the header changes from `mi=3`, then apply the
header and body changes for `mi=2`.  If this doesn't create a message which validates
with the initial `mi=1` hash, then some hop has corrupted the message.

# Security

Since a Message-Instance header can be used to recreate any email content, implementations
need to be aware that this could be used to bypass security checks, and passing the
generated message to a parser could expose it to content that would otherwise be blocked
by earlier security checks, e.g. the base64 output could generate 8-bit content or NULL
bytes that would otherwise be blocked by a simple filter.

# IANA Considerations

IANA is requested to add to the Permanent Message Header Field Names registry
the following record.

* Header Field Name: Message-Instance
* Template:
* Protocol: mail
* Status: standard
* Trace: no
* Reference: this document

--- back


Changes from Earlier Versions
=============================

## draft-gondwana-dkim2-message-instance-00

* what's in a name anyway?  People didn't like "Mail" in the IETF124 meeting,
  and "Version" is confusing
* change mv= to mi=
* each header name covers ALL instances of that header name.

## draft-gondwana-dkim2-mailversion-00

* Rename this draft to "mailversion".
* Rename the header field to 'Message-Instance'
* Change 'v=' to 'mv=' so it matches DKIM2-Signature and doesn't confuse protocol versions
* Removed 't:' optional fields entirely.
* Added ha= to select the hash algorithm and documentation about how the hashes are calculated
* Renamed bin.partspec to ph.partspec for "part hash" and described it with reference to IMAP.
* Added security considerations
* Added IANA considerations

## draft-gondwana-dkim2-modification-algebra-03

* Rename header to 'MailVersion'
* Remove all requirements that it integrates with DKIM2.
* Add body hash and per-mime-part hashes (NOTE: this is a bunch of extra calculation, so
  definitely to discuss)

## draft-gondwana-dkim2-modification-algebra-02

* change the header format to have unique keys, making it fit the ABNF for these types
  of headers.
* allow easier editing of multi-value headers by always popping the first header and
  always prepending newly added headers.
* change body to use d.0, d.1, etc with the program in the value, so that the program
  ordering is reliable regardless of the parser used to read the header.

## draft-gondwana-dkim2-modification-algebra-02

* change to using line numbers rather than octet offsets
* remove d= base64 decoding capability
* for multiple lines; require a separate b= or t= for each line

## draft-gondwana-dkim2-modification-algebra-01

* rename 'DKIM2-Diff' headers to 'DKIM2-Delta'
* add 'z=y' option to DKIM2-Delta-Body for "complete replacement"
* add d= base64 decoding option to DKIM2-Delta-Body

## draft-gondwana-dkim2-modification-algebra-00

* original version

\[\[This section to be removed by RFC Editor\]\]

